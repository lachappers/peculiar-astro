import"kleur/colors";import{clsx}from"clsx";import"cssesc";import{escape}from"html-escaper";function normalizeLF(e){return e.replace(/\r\n|\r(?!\n)|\n/g,"\n")}function codeFrame(e,t){if(!t||void 0===t.line||void 0===t.column)return"";const r=normalizeLF(e).split("\n").map((e=>e.replace(/\t/g,"  "))),n=[];for(let e=-2;e<=2;e++)r[t.line+e]&&n.push(t.line+e);let o=0;for(const e of n){let t=`> ${e}`;t.length>o&&(o=t.length)}let i="";for(const e of n){const n=e===t.line-1;i+=n?"> ":"  ",i+=`${e+1} | ${r[e]}\n`,n&&(i+=`${Array.from({length:o}).join(" ")}  | ${Array.from({length:t.column}).join(" ")}^\n`)}return i}class AstroError extends Error{loc;title;hint;frame;type="AstroError";constructor(e,t){const{name:r,title:n,message:o,stack:i,location:s,hint:a,frame:l}=e;super(o,t),this.title=n,this.name=r,o&&(this.message=o),this.stack=i||this.stack,this.loc=s,this.hint=a,this.frame=l}setLocation(e){this.loc=e}setName(e){this.name=e}setMessage(e){this.message=e}setHint(e){this.hint=e}setFrame(e,t){this.frame=codeFrame(e,t)}static is(e){return"AstroError"===e.type}}const OnlyResponseCanBeReturned={name:"OnlyResponseCanBeReturned",title:"Invalid type returned by Astro page.",message:(e,t)=>`Route \`${e||""}\` returned a \`${t}\`. Only a [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) can be returned from Astro files.`,hint:"See https://docs.astro.build/en/guides/server-side-rendering/#response for more information."},MissingMediaQueryDirective={name:"MissingMediaQueryDirective",title:"Missing value for `client:media` directive.",message:'Media query not provided for `client:media` directive. A media query similar to `client:media="(max-width: 600px)"` must be provided'},NoMatchingRenderer={name:"NoMatchingRenderer",title:"No matching renderer found.",message:(e,t,r,n)=>`Unable to render \`${e}\`.\n\n${n>0?`There ${r?"are":"is"} ${n} renderer${r?"s":""} configured in your \`astro.config.mjs\` file,\nbut ${r?"none were":"it was not"} able to server-side render \`${e}\`.`:"No valid renderer was found "+(t?`for the \`.${t}\` file extension.`:"for this file extension.")}`,hint:e=>`Did you mean to enable the ${e} integration?\n\nSee https://docs.astro.build/en/guides/framework-components/ for more information on how to install and configure integrations.`},NoClientEntrypoint={name:"NoClientEntrypoint",title:"No client entrypoint specified in renderer.",message:(e,t,r)=>`\`${e}\` component has a \`client:${t}\` directive, but no client entrypoint was provided by \`${r}\`.`,hint:"See https://docs.astro.build/en/reference/integrations-reference/#addrenderer-option for more information on how to configure your renderer."},NoClientOnlyHint={name:"NoClientOnlyHint",title:"Missing hint on client:only directive.",message:e=>`Unable to render \`${e}\`. When using the \`client:only\` hydration strategy, Astro needs a hint to use the correct renderer.`,hint:e=>`Did you mean to pass \`client:only="${e}"\`? See https://docs.astro.build/en/reference/directives-reference/#clientonly for more information on client:only`},NoMatchingImport={name:"NoMatchingImport",title:"No import found for component.",message:e=>`Could not render \`${e}\`. No matching import has been found for \`${e}\`.`,hint:"Please make sure the component is properly imported."},InvalidComponentArgs={name:"InvalidComponentArgs",title:"Invalid component arguments.",message:e=>`Invalid arguments passed to${e?` <${e}>`:""} component.`,hint:"Astro components cannot be rendered directly via function call, such as `Component()` or `{items.map(Component)}`."},ImageMissingAlt={name:"ImageMissingAlt",title:'Image missing required "alt" property.',message:'Image missing "alt" property. "alt" text is required to describe important images on the page.',hint:'Use an empty string ("") for decorative images.'},InvalidImageService={name:"InvalidImageService",title:"Error while loading image service.",message:"There was an error loading the configured image service. Please see the stack trace for more information."},MissingImageDimension={name:"MissingImageDimension",title:"Missing image dimensions",message:(e,t)=>`Missing ${"both"===e?"width and height attributes":`${e} attribute`} for ${t}. When using remote images, both dimensions are always required in order to avoid CLS.`,hint:"If your image is inside your `src` folder, you probably meant to import it instead. See [the Imports guide for more information](https://docs.astro.build/en/guides/imports/#other-assets)."},UnsupportedImageFormat={name:"UnsupportedImageFormat",title:"Unsupported image format",message:(e,t,r)=>`Received unsupported format \`${e}\` from \`${t}\`. Currently only ${r.join(", ")} are supported by our image services.`,hint:"Using an `img` tag directly instead of the `Image` component might be what you're looking for."},UnsupportedImageConversion={name:"UnsupportedImageConversion",title:"Unsupported image conversion",message:"Converting between vector (such as SVGs) and raster (such as PNGs and JPEGs) images is not currently supported."},ExpectedImage={name:"ExpectedImage",title:"Expected src to be an image.",message:(e,t,r)=>`Expected \`src\` property for \`getImage\` or \`<Image />\` to be either an ESM imported image or a string with the path of a remote image. Received \`${e}\` (type: \`${t}\`).\n\nFull serialized options received: \`${r}\`.`,hint:"This error can often happen because of a wrong path. Make sure the path to your image is correct. If you're passing an async function, make sure to call and await it."},ExpectedImageOptions={name:"ExpectedImageOptions",title:"Expected image options.",message:e=>`Expected getImage() parameter to be an object. Received \`${e}\`.`},IncompatibleDescriptorOptions={name:"IncompatibleDescriptorOptions",title:"Cannot set both `densities` and `widths`",message:"Only one of `densities` or `widths` can be specified. In most cases, you'll probably want to use only `widths` if you require specific widths.",hint:"Those attributes are used to construct a `srcset` attribute, which cannot have both `x` and `w` descriptors."},LocalImageUsedWrongly={name:"LocalImageUsedWrongly",title:"Local images must be imported.",message:e=>`\`Image\`'s and \`getImage\`'s \`src\` parameter must be an imported image or an URL, it cannot be a string filepath. Received \`${e}\`.`,hint:"If you want to use an image from your `src` folder, you need to either import it or if the image is coming from a content collection, use the [image() schema helper](https://docs.astro.build/en/guides/images/#images-in-content-collections). See https://docs.astro.build/en/guides/images/#src-required for more information on the `src` property."},AstroGlobUsedOutside={name:"AstroGlobUsedOutside",title:"Astro.glob() used outside of an Astro file.",message:e=>`\`Astro.glob(${e})\` can only be used in \`.astro\` files. \`import.meta.glob(${e})\` can be used instead to achieve a similar result.`,hint:"See Vite's documentation on `import.meta.glob` for more information: https://vitejs.dev/guide/features.html#glob-import"},AstroGlobNoMatch={name:"AstroGlobNoMatch",title:"Astro.glob() did not match any files.",message:e=>`\`Astro.glob(${e})\` did not return any matching files.`,hint:"Check the pattern for typos."},MissingSharp={name:"MissingSharp",title:"Could not find Sharp.",message:"Could not find Sharp. Please install Sharp (`sharp`) manually into your project or migrate to another image service.",hint:"See Sharp's installation instructions for more information: https://sharp.pixelplumbing.com/install. If you are not relying on `astro:assets` to optimize, transform, or process any images, you can configure a passthrough image service instead of installing Sharp. See https://docs.astro.build/en/reference/errors/missing-sharp for more information.\n\nSee https://docs.astro.build/en/guides/images/#default-image-service for more information on how to migrate to another image service."};function validateArgs(e){return 3===e.length&&!(!e[0]||"object"!=typeof e[0])}function baseCreateComponent(e,t,r){const n=t?.split("/").pop()?.replace(".astro","")??"",o=(...t)=>{if(!validateArgs(t))throw new AstroError({...InvalidComponentArgs,message:InvalidComponentArgs.message(n)});return e(...t)};return Object.defineProperty(o,"name",{value:n,writable:!1}),o.isAstroComponentFactory=!0,o.moduleId=t,o.propagation=r,o}function createComponentWithOptions(e){return baseCreateComponent(e.factory,e.moduleId,e.propagation)}function createComponent(e,t,r){return"function"==typeof e?baseCreateComponent(e,t,r):createComponentWithOptions(e)}const ASTRO_VERSION="4.3.5";function createAstroGlobFn(){return e=>{if("string"==typeof e)throw new AstroError({...AstroGlobUsedOutside,message:AstroGlobUsedOutside.message(JSON.stringify(e))});let t=[...Object.values(e)];if(0===t.length)throw new AstroError({...AstroGlobNoMatch,message:AstroGlobNoMatch.message(JSON.stringify(e))});return Promise.all(t.map((e=>e())))}}function createAstro(e){return{site:e?new URL(e):void 0,generator:"Astro v4.3.5",glob:createAstroGlobFn()}}function isPromise(e){return!!e&&"object"==typeof e&&"function"==typeof e.then}async function*streamAsyncIterator(e){const t=e.getReader();try{for(;;){const{done:e,value:r}=await t.read();if(e)return;yield r}}finally{t.releaseLock()}}const escapeHTML=escape;class HTMLBytes extends Uint8Array{}Object.defineProperty(HTMLBytes.prototype,Symbol.toStringTag,{get:()=>"HTMLBytes"});class HTMLString extends String{get[Symbol.toStringTag](){return"HTMLString"}}const markHTMLString=e=>e instanceof HTMLString?e:"string"==typeof e?new HTMLString(e):e;function isHTMLString(e){return"[object HTMLString]"===Object.prototype.toString.call(e)}function markHTMLBytes(e){return new HTMLBytes(e)}function hasGetReader(e){return"function"==typeof e.getReader}async function*unescapeChunksAsync(e){if(hasGetReader(e))for await(const t of streamAsyncIterator(e))yield unescapeHTML(t);else for await(const t of e)yield unescapeHTML(t)}function*unescapeChunks(e){for(const t of e)yield unescapeHTML(t)}function unescapeHTML(e){if(e&&"object"==typeof e){if(e instanceof Uint8Array)return markHTMLBytes(e);if(e instanceof Response&&e.body){return unescapeChunksAsync(e.body)}if("function"==typeof e.then)return Promise.resolve(e).then((e=>unescapeHTML(e)));if(Symbol.iterator in e)return unescapeChunks(e);if(Symbol.asyncIterator in e||hasGetReader(e))return unescapeChunksAsync(e)}return markHTMLString(e)}const RenderInstructionSymbol=Symbol.for("astro:render");function createRenderInstruction(e){return Object.defineProperty(e,RenderInstructionSymbol,{value:!0})}function isRenderInstruction(e){return e&&"object"==typeof e&&e[RenderInstructionSymbol]}const PROP_TYPE={Value:0,JSON:1,RegExp:2,Date:3,Map:4,Set:5,BigInt:6,URL:7,Uint8Array:8,Uint16Array:9,Uint32Array:10};function serializeArray(e,t={},r=new WeakSet){if(r.has(e))throw new Error(`Cyclic reference detected while serializing props for <${t.displayName} client:${t.hydrate}>!\n\nCyclic references cannot be safely serialized for client-side usage. Please remove the cyclic reference.`);r.add(e);const n=e.map((e=>convertToSerializedForm(e,t,r)));return r.delete(e),n}function serializeObject(e,t={},r=new WeakSet){if(r.has(e))throw new Error(`Cyclic reference detected while serializing props for <${t.displayName} client:${t.hydrate}>!\n\nCyclic references cannot be safely serialized for client-side usage. Please remove the cyclic reference.`);r.add(e);const n=Object.fromEntries(Object.entries(e).map((([e,n])=>[e,convertToSerializedForm(n,t,r)])));return r.delete(e),n}function convertToSerializedForm(e,t={},r=new WeakSet){switch(Object.prototype.toString.call(e)){case"[object Date]":return[PROP_TYPE.Date,e.toISOString()];case"[object RegExp]":return[PROP_TYPE.RegExp,e.source];case"[object Map]":return[PROP_TYPE.Map,serializeArray(Array.from(e),t,r)];case"[object Set]":return[PROP_TYPE.Set,serializeArray(Array.from(e),t,r)];case"[object BigInt]":return[PROP_TYPE.BigInt,e.toString()];case"[object URL]":return[PROP_TYPE.URL,e.toString()];case"[object Array]":return[PROP_TYPE.JSON,serializeArray(e,t,r)];case"[object Uint8Array]":return[PROP_TYPE.Uint8Array,Array.from(e)];case"[object Uint16Array]":return[PROP_TYPE.Uint16Array,Array.from(e)];case"[object Uint32Array]":return[PROP_TYPE.Uint32Array,Array.from(e)];default:return null!==e&&"object"==typeof e?[PROP_TYPE.Value,serializeObject(e,t,r)]:void 0===e?[PROP_TYPE.Value]:[PROP_TYPE.Value,e]}}function serializeProps(e,t){return JSON.stringify(serializeObject(e,t))}const transitionDirectivesToCopyOnIsland=Object.freeze(["data-astro-transition-scope","data-astro-transition-persist"]);function extractDirectives(e,t){let r={isPage:!1,hydration:null,props:{},propsWithoutTransitionAttributes:{}};for(const[n,o]of Object.entries(e))if(n.startsWith("server:")&&"server:root"===n&&(r.isPage=!0),n.startsWith("client:"))switch(r.hydration||(r.hydration={directive:"",value:"",componentUrl:"",componentExport:{value:""}}),n){case"client:component-path":r.hydration.componentUrl=o;break;case"client:component-export":r.hydration.componentExport.value=o;break;case"client:component-hydration":case"client:display-name":break;default:if(r.hydration.directive=n.split(":")[1],r.hydration.value=o,!t.has(r.hydration.directive)){const e=Array.from(t.keys()).map((e=>`client:${e}`)).join(", ");throw new Error(`Error: invalid hydration directive "${n}". Supported hydration methods: ${e}`)}if("media"===r.hydration.directive&&"string"!=typeof r.hydration.value)throw new AstroError(MissingMediaQueryDirective)}else r.props[n]=o,transitionDirectivesToCopyOnIsland.includes(n)||(r.propsWithoutTransitionAttributes[n]=o);for(const t of Object.getOwnPropertySymbols(e))r.props[t]=e[t],r.propsWithoutTransitionAttributes[t]=e[t];return r}async function generateHydrateScript(e,t){const{renderer:r,result:n,astroId:o,props:i,attrs:s}=e,{hydrate:a,componentUrl:l,componentExport:c}=t;if(!c.value)throw new AstroError({...NoMatchingImport,message:NoMatchingImport.message(t.displayName)});const d={children:"",props:{uid:o}};if(s)for(const[e,t]of Object.entries(s))d.props[e]=escapeHTML(t);d.props["component-url"]=await n.resolve(decodeURI(l)),r.clientEntrypoint&&(d.props["component-export"]=c.value,d.props["renderer-url"]=await n.resolve(decodeURI(r.clientEntrypoint)),d.props.props=escapeHTML(serializeProps(i,t))),d.props.ssr="",d.props.client=a;let p=await n.resolve("astro:scripts/before-hydration.js");return p.length&&(d.props["before-hydration-url"]=p),d.props.opts=escapeHTML(JSON.stringify({name:t.displayName,value:t.hydrateArgs||""})),transitionDirectivesToCopyOnIsland.forEach((e=>{i[e]&&(d.props[e]=i[e])})),d}const dictionary="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXY",binary=dictionary.length;function bitwise(e){let t=0;if(0===e.length)return t;for(let r=0;r<e.length;r++){t=(t<<5)-t+e.charCodeAt(r),t&=t}return t}function shorthash(e){let t,r="",n=bitwise(e);const o=n<0?"Z":"";for(n=Math.abs(n);n>=binary;)t=n%binary,n=Math.floor(n/binary),r=dictionary[t]+r;return n>0&&(r=dictionary[n]+r),o+r}function isAstroComponentFactory(e){return null!=e&&!0===e.isAstroComponentFactory}function isAPropagatingComponent(e,t){let r=t.propagation||"none";return t.moduleId&&e.componentMetadata.has(t.moduleId)&&"none"===r&&(r=e.componentMetadata.get(t.moduleId).propagation),"in-tree"===r||"self"===r}const headAndContentSym=Symbol.for("astro.headAndContent");function isHeadAndContent(e){return"object"==typeof e&&!!e[headAndContentSym]}var astro_island_prebuilt_default='(()=>{var b=Object.defineProperty;var f=(c,o,i)=>o in c?b(c,o,{enumerable:!0,configurable:!0,writable:!0,value:i}):c[o]=i;var l=(c,o,i)=>(f(c,typeof o!="symbol"?o+"":o,i),i);var p;{let c={0:t=>m(t),1:t=>i(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(i(t)),5:t=>new Set(i(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t)},o=t=>{let[e,r]=t;return e in c?c[e](r):void 0},i=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([e,r])=>[e,o(r)]));customElements.get("astro-island")||customElements.define("astro-island",(p=class extends HTMLElement{constructor(){super(...arguments);l(this,"Component");l(this,"hydrator");l(this,"hydrate",async()=>{var d;if(!this.hydrator||!this.isConnected)return;let e=(d=this.parentElement)==null?void 0:d.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let r=this.querySelectorAll("astro-slot"),a={},h=this.querySelectorAll("template[data-astro-template]");for(let n of h){let s=n.closest(this.tagName);s!=null&&s.isSameNode(this)&&(a[n.getAttribute("data-astro-template")||"default"]=n.innerHTML,n.remove())}for(let n of r){let s=n.closest(this.tagName);s!=null&&s.isSameNode(this)&&(a[n.getAttribute("name")||"default"]=n.innerHTML)}let u;try{u=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(n){let s=this.getAttribute("component-url")||"<unknown>",y=this.getAttribute("component-export");throw y&&(s+=` (export ${y})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),n),n}await this.hydrator(this)(this.Component,u,a,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});l(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),r.disconnect(),this.childrenConnectedCallback()},r=new MutationObserver(()=>{var a;((a=this.lastChild)==null?void 0:a.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});r.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}start(){let e=JSON.parse(this.getAttribute("opts")),r=this.getAttribute("client");if(Astro[r]===void 0){window.addEventListener(`astro:${r}`,()=>this.start(),{once:!0});return}Astro[r](async()=>{let a=this.getAttribute("renderer-url"),[h,{default:u}]=await Promise.all([import(this.getAttribute("component-url")),a?import(a):()=>()=>{}]),d=this.getAttribute("component-export")||"default";if(!d.includes("."))this.Component=h[d];else{this.Component=h;for(let n of d.split("."))this.Component=this.Component[n]}return this.hydrator=u,this.hydrate},e,this)}attributeChangedCallback(){this.hydrate()}},l(p,"observedAttributes",["props"]),p))}})();';const ISLAND_STYLES="<style>astro-island,astro-slot,astro-static-slot{display:contents}</style>";function determineIfNeedsHydrationScript(e){return!e._metadata.hasHydrationScript&&(e._metadata.hasHydrationScript=!0)}function determinesIfNeedsDirectiveScript(e,t){return!e._metadata.hasDirectives.has(t)&&(e._metadata.hasDirectives.add(t),!0)}function getDirectiveScriptText(e,t){const r=e.clientDirectives.get(t);if(!r)throw new Error(`Unknown directive: ${t}`);return r}function getPrescripts(e,t,r){switch(t){case"both":return`${ISLAND_STYLES}<script>${getDirectiveScriptText(e,r)};${astro_island_prebuilt_default}<\/script>`;case"directive":return`<script>${getDirectiveScriptText(e,r)}<\/script>`}return""}const voidElementNames=/^(area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i,htmlBooleanAttributes=/^(?:allowfullscreen|async|autofocus|autoplay|controls|default|defer|disabled|disablepictureinpicture|disableremoteplayback|formnovalidate|hidden|loop|nomodule|novalidate|open|playsinline|readonly|required|reversed|scoped|seamless|itemscope)$/i,htmlEnumAttributes=/^(?:contenteditable|draggable|spellcheck|value)$/i,svgEnumAttributes=/^(?:autoReverse|externalResourcesRequired|focusable|preserveAlpha)$/i,STATIC_DIRECTIVES=new Set(["set:html","set:text"]),toIdent=e=>e.trim().replace(/(?!^)\b\w|\s+|\W+/g,((e,t)=>/\W/.test(e)?"":0===t?e:e.toUpperCase())),toAttributeString=(e,t=!0)=>t?String(e).replace(/&/g,"&#38;").replace(/"/g,"&#34;"):e,kebab=e=>e.toLowerCase()===e?e:e.replace(/[A-Z]/g,(e=>`-${e.toLowerCase()}`)),toStyleString=e=>Object.entries(e).filter((([e,t])=>"string"==typeof t&&t.trim()||"number"==typeof t)).map((([e,t])=>"-"!==e[0]&&"-"!==e[1]?`${kebab(e)}:${t}`:`${e}:${t}`)).join(";");function defineScriptVars(e){let t="";for(const[r,n]of Object.entries(e))t+=`const ${toIdent(r)} = ${JSON.stringify(n)?.replace(/<\/script>/g,"\\x3C/script>")};\n`;return markHTMLString(t)}function formatList(e){return 1===e.length?e[0]:`${e.slice(0,-1).join(", ")} or ${e[e.length-1]}`}function addAttribute(e,t,r=!0){if(null==e)return"";if(!1===e)return htmlEnumAttributes.test(t)||svgEnumAttributes.test(t)?markHTMLString(` ${t}="false"`):"";if(STATIC_DIRECTIVES.has(t))return console.warn(`[astro] The "${t}" directive cannot be applied dynamically at runtime. It will not be rendered as an attribute.\n\nMake sure to use the static attribute syntax (\`${t}={value}\`) instead of the dynamic spread syntax (\`{...{ "${t}": value }}\`).`),"";if("class:list"===t){const n=toAttributeString(clsx(e),r);return""===n?"":markHTMLString(` ${t.slice(0,-5)}="${n}"`)}if("style"===t&&!(e instanceof HTMLString)){if(Array.isArray(e)&&2===e.length)return markHTMLString(` ${t}="${toAttributeString(`${toStyleString(e[0])};${e[1]}`,r)}"`);if("object"==typeof e)return markHTMLString(` ${t}="${toAttributeString(toStyleString(e),r)}"`)}return"className"===t?markHTMLString(` class="${toAttributeString(e,r)}"`):!0===e&&(t.startsWith("data-")||htmlBooleanAttributes.test(t))?markHTMLString(` ${t}`):markHTMLString(` ${t}="${toAttributeString(e,r)}"`)}function internalSpreadAttributes(e,t=!0){let r="";for(const[n,o]of Object.entries(e))r+=addAttribute(o,n,t);return markHTMLString(r)}function renderElement$1(e,{props:t,children:r=""},n=!0){const{lang:o,"data-astro-id":i,"define:vars":s,...a}=t;return s&&("style"===e&&(delete a["is:global"],delete a["is:scoped"]),"script"===e&&(delete a.hoist,r=defineScriptVars(s)+"\n"+r)),null!=r&&""!=r||!voidElementNames.test(e)?`<${e}${internalSpreadAttributes(a,n)}>${r}</${e}>`:`<${e}${internalSpreadAttributes(a,n)} />`}function renderToBufferDestination(e){const t=[],r={write:e=>t.push(e)},n=e(r);return{async renderToFinalDestination(e){for(const r of t)e.write(r);r.write=t=>e.write(t),await n}}}const uniqueElements=(e,t,r)=>{const n=JSON.stringify(e.props),o=e.children;return t===r.findIndex((e=>JSON.stringify(e.props)===n&&e.children==o))};function renderAllHeadContent(e){e._metadata.hasRenderedHead=!0;const t=Array.from(e.styles).filter(uniqueElements).map((e=>"stylesheet"===e.props.rel?renderElement$1("link",e):renderElement$1("style",e)));e.styles.clear();const r=Array.from(e.scripts).filter(uniqueElements).map((e=>renderElement$1("script",e,!1))),n=Array.from(e.links).filter(uniqueElements).map((e=>renderElement$1("link",e,!1)));let o=t.join("\n")+n.join("\n")+r.join("\n");if(e._metadata.extraHead.length>0)for(const t of e._metadata.extraHead)o+=t;return markHTMLString(o)}function*renderHead(){yield createRenderInstruction({type:"head"})}function*maybeRenderHead(){yield createRenderInstruction({type:"maybe-head"})}const slotString=Symbol.for("astro:slot-string");class SlotString extends HTMLString{instructions;[slotString];constructor(e,t){super(e),this.instructions=t,this[slotString]=!0}}function isSlotString(e){return!!e[slotString]}function renderSlot(e,t,r){return!t&&r?renderSlot(e,r):{async render(r){await renderChild(r,"function"==typeof t?t(e):t)}}}async function renderSlotToString(e,t,r){let n="",o=null;const i={write(t){t instanceof Response||("object"==typeof t&&"type"in t&&"string"==typeof t.type?(null===o&&(o=[]),o.push(t)):n+=chunkToString(e,t))}},s=renderSlot(e,t,r);return await s.render(i),markHTMLString(new SlotString(n,o))}async function renderSlots(e,t={}){let r=null,n={};return t&&await Promise.all(Object.entries(t).map((([t,o])=>renderSlotToString(e,o).then((e=>{e.instructions&&(null===r&&(r=[]),r.push(...e.instructions)),n[t]=e}))))),{slotInstructions:r,children:n}}const Fragment=Symbol.for("astro:fragment"),Renderer=Symbol.for("astro:renderer");new TextEncoder;const decoder=new TextDecoder;function stringifyChunk(e,t){if(isRenderInstruction(t)){const r=t;switch(r.type){case"directive":{const{hydration:t}=r;let n=t&&determineIfNeedsHydrationScript(e),o=t&&determinesIfNeedsDirectiveScript(e,t.directive),i=n?"both":o?"directive":null;if(i){let r=getPrescripts(e,i,t.directive);return markHTMLString(r)}return""}case"head":return e._metadata.hasRenderedHead||e.partial?"":renderAllHeadContent(e);case"maybe-head":return e._metadata.hasRenderedHead||e._metadata.headInTree||e.partial?"":renderAllHeadContent(e);case"renderer-hydration-script":{const{rendererSpecificHydrationScripts:t}=e._metadata,{rendererName:n}=r;return t.has(n)?"":(t.add(n),r.render())}default:throw new Error(`Unknown chunk type: ${t.type}`)}}else{if(t instanceof Response)return"";if(isSlotString(t)){let r="";const n=t;if(n.instructions)for(const t of n.instructions)r+=stringifyChunk(e,t);return r+=t.toString(),r}}return t.toString()}function chunkToString(e,t){return ArrayBuffer.isView(t)?decoder.decode(t):stringifyChunk(e,t)}function isRenderInstance(e){return!!e&&"object"==typeof e&&"render"in e&&"function"==typeof e.render}async function renderChild(e,t){if((t=await t)instanceof SlotString)e.write(t);else if(isHTMLString(t))e.write(t);else if(Array.isArray(t)){const r=t.map((e=>renderToBufferDestination((t=>renderChild(t,e)))));for(const t of r)t&&await t.renderToFinalDestination(e)}else if("function"==typeof t)await renderChild(e,t());else if("string"==typeof t)e.write(markHTMLString(escapeHTML(t)));else if(t||0===t)if(isRenderInstance(t))await t.render(e);else if(isRenderTemplateResult(t))await t.render(e);else if(isAstroComponentInstance(t))await t.render(e);else if(ArrayBuffer.isView(t))e.write(t);else if("object"==typeof t&&(Symbol.asyncIterator in t||Symbol.iterator in t))for await(const r of t)await renderChild(e,r);else e.write(t);else;}const astroComponentInstanceSym=Symbol.for("astro.componentInstance");class AstroComponentInstance{[astroComponentInstanceSym]=!0;result;props;slotValues;factory;returnValue;constructor(e,t,r,n){this.result=e,this.props=t,this.factory=n,this.slotValues={};for(const t in r){let n=!1,o=r[t](e);this.slotValues[t]=()=>n?r[t](e):(n=!0,o)}}async init(e){return void 0!==this.returnValue||(this.returnValue=this.factory(e,this.props,this.slotValues)),this.returnValue}async render(e){void 0===this.returnValue&&await this.init(this.result);let t=this.returnValue;isPromise(t)&&(t=await t),isHeadAndContent(t)?await t.content.render(e):await renderChild(e,t)}}function validateComponentProps(e,t){if(null!=e)for(const r of Object.keys(e))r.startsWith("client:")&&console.warn(`You are attempting to render <${t} ${r} />, but ${t} is an Astro component. Astro components do not render in the client and should not have a hydration directive. Please use a framework component for client rendering.`)}function createAstroComponentInstance(e,t,r,n,o={}){validateComponentProps(n,t);const i=new AstroComponentInstance(e,n,o,r);return isAPropagatingComponent(e,r)&&e._metadata.propagators.add(i),i}function isAstroComponentInstance(e){return"object"==typeof e&&!!e[astroComponentInstanceSym]}const renderTemplateResultSym=Symbol.for("astro.renderTemplateResult");class RenderTemplateResult{[renderTemplateResultSym]=!0;htmlParts;expressions;error;constructor(e,t){this.htmlParts=e,this.error=void 0,this.expressions=t.map((e=>isPromise(e)?Promise.resolve(e).catch((e=>{if(!this.error)throw this.error=e,e})):e))}async render(e){const t=this.expressions.map((e=>renderToBufferDestination((t=>{if(e||0===e)return renderChild(t,e)}))));for(let r=0;r<this.htmlParts.length;r++){const n=this.htmlParts[r],o=t[r];e.write(markHTMLString(n)),o&&await o.renderToFinalDestination(e)}}}function isRenderTemplateResult(e){return"object"==typeof e&&!!e[renderTemplateResultSym]}function renderTemplate(e,...t){return new RenderTemplateResult(e,t)}async function renderToString(e,t,r,n,o=!1,i){const s=await callComponentAsTemplateResultOrResponse(e,t,r,n,i);if(s instanceof Response)return s;let a="",l=!1;const c={write(t){if(o&&!l&&(l=!0,!e.partial&&!/<!doctype html/i.test(String(t)))){const t=e.compressHTML?"<!DOCTYPE html>":"<!DOCTYPE html>\n";a+=t}t instanceof Response||(a+=chunkToString(e,t))}};return await s.render(c),a}async function callComponentAsTemplateResultOrResponse(e,t,r,n,o){const i=await t(e,r,n);if(i instanceof Response)return i;if(!isRenderTemplateResult(i))throw new AstroError({...OnlyResponseCanBeReturned,message:OnlyResponseCanBeReturned.message(o?.route,typeof i),location:{file:o?.component}});return isHeadAndContent(i)?i.content:i}function componentIsHTMLElement(e){return"undefined"!=typeof HTMLElement&&HTMLElement.isPrototypeOf(e)}async function renderHTMLElement(e,t,r,n){const o=getHTMLElementName(t);let i="";for(const e in r)i+=` ${e}="${toAttributeString(await r[e])}"`;return markHTMLString(`<${o}${i}>${await renderSlotToString(e,n?.default)}</${o}>`)}function getHTMLElementName(e){const t=customElements.getName(e);if(t)return t;return e.name.replace(/^HTML|Element$/g,"").replace(/[A-Z]/g,"-$&").toLowerCase().replace(/^-/,"html-")}const needsHeadRenderingSymbol=Symbol.for("astro.needsHeadRendering"),rendererAliases=new Map([["solid","solid-js"]]);function guessRenderers(e){const t=e?.split(".").pop();switch(t){case"svelte":return["@astrojs/svelte"];case"vue":return["@astrojs/vue"];case"jsx":case"tsx":return["@astrojs/react","@astrojs/preact","@astrojs/solid-js","@astrojs/vue (jsx)"];default:return["@astrojs/react","@astrojs/preact","@astrojs/solid-js","@astrojs/vue","@astrojs/svelte","@astrojs/lit"]}}function isFragmentComponent(e){return e===Fragment}function isHTMLComponent(e){return e&&!0===e["astro:html"]}const ASTRO_SLOT_EXP=/<\/?astro-slot\b[^>]*>/g,ASTRO_STATIC_SLOT_EXP=/<\/?astro-static-slot\b[^>]*>/g;function removeStaticAstroSlot(e,t){const r=t?ASTRO_STATIC_SLOT_EXP:ASTRO_SLOT_EXP;return e.replace(r,"")}async function renderFrameworkComponent(e,t,r,n,o={}){if(!r&&!n["client:only"])throw new Error(`Unable to render ${t} because it is ${r}!\nDid you forget to import the component or is it possible there is a typo?`);const{renderers:i,clientDirectives:s}=e,a={astroStaticSlot:!0,displayName:t},{hydration:l,isPage:c,props:d,propsWithoutTransitionAttributes:p}=extractDirectives(n,s);let u,m="";l&&(a.hydrate=l.directive,a.hydrateArgs=l.value,a.componentExport=l.componentExport,a.componentUrl=l.componentUrl);const f=guessRenderers(a.componentUrl),h=i.filter((e=>"astro:jsx"!==e.name)),{children:y,slotInstructions:g}=await renderSlots(e,o);let b;if("only"!==a.hydrate){let t=!1;try{t=r&&r[Renderer]}catch{}if(t){const e=r[Renderer];b=i.find((({name:t})=>t===e))}if(!b){let t;for(const n of i)try{if(await n.ssr.check.call({result:e},r,d,y)){b=n;break}}catch(e){t??=e}if(!b&&t)throw t}if(!b&&"function"==typeof HTMLElement&&componentIsHTMLElement(r)){const t=await renderHTMLElement(e,r,n,o);return{render(e){e.write(t)}}}}else{if(a.hydrateArgs){const e=a.hydrateArgs,t=rendererAliases.has(e)?rendererAliases.get(e):e;b=i.find((({name:e})=>e===`@astrojs/${t}`||e===t))}if(b||1!==h.length||(b=h[0]),!b){const e=a.componentUrl?.split(".").pop();b=i.filter((({name:t})=>t===`@astrojs/${e}`||t===e))[0]}}if(b)"only"===a.hydrate?m=await renderSlotToString(e,o?.fallback):({html:m,attrs:u}=await b.ssr.renderToStaticMarkup.call({result:e},r,p,y,a));else{if("only"===a.hydrate)throw new AstroError({...NoClientOnlyHint,message:NoClientOnlyHint.message(a.displayName),hint:NoClientOnlyHint.hint(f.map((e=>e.replace("@astrojs/",""))).join("|"))});if("string"!=typeof r){const t=h.filter((e=>f.includes(e.name))),n=h.length>1;if(0===t.length)throw new AstroError({...NoMatchingRenderer,message:NoMatchingRenderer.message(a.displayName,a?.componentUrl?.split(".").pop(),n,h.length),hint:NoMatchingRenderer.hint(formatList(f.map((e=>"`"+e+"`"))))});if(1!==t.length)throw new Error(`Unable to render ${a.displayName}!\n\nThis component likely uses ${formatList(f)},\nbut Astro encountered an error during server-side rendering.\n\nPlease ensure that ${a.displayName}:\n1. Does not unconditionally access browser-specific globals like \`window\` or \`document\`.\n   If this is unavoidable, use the \`client:only\` hydration directive.\n2. Does not conditionally return \`null\` or \`undefined\` when rendered on the server.\n\nIf you're still stuck, please open an issue on GitHub or join us at https://astro.build/chat.`);b=t[0],({html:m,attrs:u}=await b.ssr.renderToStaticMarkup.call({result:e},r,p,y,a))}}if(b&&!b.clientEntrypoint&&"@astrojs/lit"!==b.name&&a.hydrate)throw new AstroError({...NoClientEntrypoint,message:NoClientEntrypoint.message(t,a.hydrate,b.name)});if(!m&&"string"==typeof r){const t=sanitizeElementName(r),n=Object.values(y).join(""),o=renderTemplate`<${t}${internalSpreadAttributes(d)}${markHTMLString(""===n&&voidElementNames.test(t)?"/>":`>${n}</${t}>`)}`;m="";const i={write(t){t instanceof Response||(m+=chunkToString(e,t))}};await o.render(i)}if(!l)return{render(e){if(g)for(const t of g)e.write(t);c||"astro:jsx"===b?.name?e.write(m):m&&m.length>0&&e.write(markHTMLString(removeStaticAstroSlot(m,b?.ssr?.supportsAstroStaticSlot??!1)))}};const S=shorthash(`\x3c!--${a.componentExport.value}:${a.componentUrl}--\x3e\n${m}\n${serializeProps(d,a)}`),w=await generateHydrateScript({renderer:b,result:e,astroId:S,props:d,attrs:u},a);let A=[];if(m){if(Object.keys(y).length>0)for(const e of Object.keys(y)){let t=b?.ssr?.supportsAstroStaticSlot?a.hydrate?"astro-slot":"astro-static-slot":"astro-slot",r="default"===e?`<${t}>`:`<${t} name="${e}">`;m.includes(r)||A.push(e)}}else A=Object.keys(y);const v=A.length>0?A.map((e=>`<template data-astro-template${"default"!==e?`="${e}"`:""}>${y[e]}</template>`)).join(""):"";return w.children=`${m??""}${v}`,w.children&&(w.props["await-children"]="",w.children+="\x3c!--astro:end--\x3e"),{render(e){if(g)for(const t of g)e.write(t);e.write(createRenderInstruction({type:"directive",hydration:l})),"only"!==l.directive&&b?.ssr.renderHydrationScript&&e.write(createRenderInstruction({type:"renderer-hydration-script",rendererName:b.name,render:b.ssr.renderHydrationScript})),e.write(markHTMLString(renderElement$1("astro-island",w,!1)))}}}function sanitizeElementName(e){const t=/[&<>'"\s]+/;return t.test(e)?e.trim().split(t)[0].trim():e}async function renderFragmentComponent(e,t={}){const r=await renderSlotToString(e,t?.default);return{render(e){null!=r&&e.write(r)}}}async function renderHTMLComponent(e,t,r,n={}){const{slotInstructions:o,children:i}=await renderSlots(e,n),s=t({slots:i}),a=o?o.map((t=>chunkToString(e,t))).join(""):"";return{render(e){e.write(markHTMLString(a+s))}}}function renderAstroComponent(e,t,r,n,o={}){const i=createAstroComponentInstance(e,t,r,n,o);return{async render(e){await i.render(e)}}}async function renderComponent(e,t,r,n,o={}){return isPromise(r)&&(r=await r),isFragmentComponent(r)?await renderFragmentComponent(e,o):(n=normalizeProps(n),isHTMLComponent(r)?await renderHTMLComponent(e,r,n,o):isAstroComponentFactory(r)?renderAstroComponent(e,t,r,n,o):await renderFrameworkComponent(e,t,r,n,o))}function normalizeProps(e){if(void 0!==e["class:list"]){const t=e["class:list"];delete e["class:list"],e.class=clsx(e.class,t),""===e.class&&delete e.class}return e}async function renderComponentToString(e,t,r,n,o={},i=!1,s){let a="",l=!1,c="";if(nonAstroPageNeedsHeadInjection(r))for(const t of maybeRenderHead())c+=chunkToString(e,t);try{const s={write(t){if(i&&!l&&(l=!0,!e.partial&&!/<!doctype html/i.test(String(t)))){const t=e.compressHTML?"<!DOCTYPE html>":"<!DOCTYPE html>\n";a+=t+c}t instanceof Response||(a+=chunkToString(e,t))}},d=await renderComponent(e,t,r,n,o);await d.render(s)}catch(e){throw AstroError.is(e)&&!e.loc&&e.setLocation({file:s?.component}),e}return a}function nonAstroPageNeedsHeadInjection(e){return!!e?.[needsHeadRenderingSymbol]}const ClientOnlyPlaceholder="astro-client-only";class Skip{constructor(e){this.vnode=e,this.count=0}count;increment(){this.count++}haveNoTried(){return 0===this.count}isCompleted(){return this.count>2}static symbol=Symbol("astro:jsx:skip")}let originalConsoleError,consoleFilterRefs=0;async function renderJSX(e,t){switch(!0){case t instanceof HTMLString:return""===t.toString().trim()?"":t;case"string"==typeof t:return markHTMLString(escapeHTML(t));case"function"==typeof t:return t;case!t&&0!==t:return"";case Array.isArray(t):return markHTMLString((await Promise.all(t.map((t=>renderJSX(e,t))))).join(""))}let r;return r=t.props&&t.props[Skip.symbol]?t.props[Skip.symbol]:new Skip(t),renderJSXVNode(e,t,r)}async function renderJSXVNode(e,t,r){if(isVNode(t)){switch(!0){case!t.type:throw new Error(`Unable to render ${e.pathname} because it contains an undefined Component!\nDid you forget to import the component or is it possible there is a typo?`);case t.type===Symbol.for("astro:fragment"):return renderJSX(e,t.props.children);case t.type.isAstroComponentFactory:{let r={},n={};for(const[o,i]of Object.entries(t.props??{}))"children"===o||i&&"object"==typeof i&&i.$$slot?n["children"===o?"default":o]=()=>renderJSX(e,i):r[o]=i;const o=await renderToString(e,t.type,r,n);if(o instanceof Response)throw o;return markHTMLString(o)}case!t.type&&0!==t.type:return"";case"string"==typeof t.type&&t.type!==ClientOnlyPlaceholder:return markHTMLString(await renderElement(e,t.type,t.props??{}))}if(t.type){let n=function(e){return Array.isArray(e)?e.map((e=>n(e))):isVNode(e)&&"slot"in e.props?(s[e.props.slot]=[...s[e.props.slot]??[],e],void delete e.props.slot):void s.default.push(e)};if("function"==typeof t.type&&t.type["astro:renderer"]&&r.increment(),"function"==typeof t.type&&t.props["server:root"]){const r=await t.type(t.props??{});return await renderJSX(e,r)}if("function"==typeof t.type)if(r.haveNoTried()||r.isCompleted()){useConsoleFilter();try{const n=await t.type(t.props??{});let o;if(n?.[AstroJSX])return o=await renderJSXVNode(e,n,r),o;if(!n)return o=await renderJSXVNode(e,n,r),o}catch(e){if(r.isCompleted())throw e;r.increment()}finally{finishUsingConsoleFilter()}}else r.increment();const{children:o=null,...i}=t.props??{},s={default:[]};n(o);for(const[e,t]of Object.entries(i))t.$$slot&&(s[e]=t,delete i[e]);const a=[],l={};for(const[t,r]of Object.entries(s))a.push(renderJSX(e,r).then((e=>{0!==e.toString().trim().length&&(l[t]=()=>e)})));let c;return await Promise.all(a),i[Skip.symbol]=r,c=t.type===ClientOnlyPlaceholder&&t.props["client:only"]?await renderComponentToString(e,t.props["client:display-name"]??"",null,i,l):await renderComponentToString(e,"function"==typeof t.type?t.type.name:t.type,t.type,i,l),markHTMLString(c)}}return markHTMLString(`${t}`)}async function renderElement(e,t,{children:r,...n}){return markHTMLString(`<${t}${spreadAttributes(n)}${markHTMLString(null!=r&&""!=r||!voidElementNames.test(t)?`>${null==r?"":await renderJSX(e,prerenderElementChildren(t,r))}</${t}>`:"/>")}`)}function prerenderElementChildren(e,t){return"string"!=typeof t||"style"!==e&&"script"!==e?t:markHTMLString(t)}function useConsoleFilter(){if(consoleFilterRefs++,!originalConsoleError){originalConsoleError=console.error;try{console.error=filteredConsoleError}catch(e){}}}function finishUsingConsoleFilter(){consoleFilterRefs--}function filteredConsoleError(e,...t){if(consoleFilterRefs>0&&"string"==typeof e){if(e.includes("Warning: Invalid hook call.")&&e.includes("https://reactjs.org/link/invalid-hook-call"))return}originalConsoleError(e,...t)}function spreadAttributes(e={},t,{class:r}={}){let n="";r&&(void 0!==e.class?e.class+=` ${r}`:void 0!==e["class:list"]?e["class:list"]=[e["class:list"],r]:e.class=r);for(const[t,r]of Object.entries(e))n+=addAttribute(r,t,!0);return markHTMLString(n)}const AstroJSX="astro:jsx",Empty=Symbol("empty"),toSlotName=e=>e;function isVNode(e){return e&&"object"==typeof e&&e[AstroJSX]}function transformSlots(e){if("string"==typeof e.type)return e;const t={};if(isVNode(e.props.children)){const r=e.props.children;if(!isVNode(r))return;if(!("slot"in r.props))return;const n=toSlotName(r.props.slot);t[n]=[r],t[n].$$slot=!0,delete r.props.slot,delete e.props.children}Array.isArray(e.props.children)&&(e.props.children=e.props.children.map((e=>{if(!isVNode(e))return e;if(!("slot"in e.props))return e;const r=toSlotName(e.props.slot);return Array.isArray(t[r])?t[r].push(e):(t[r]=[e],t[r].$$slot=!0),delete e.props.slot,Empty})).filter((e=>e!==Empty))),Object.assign(e.props,t)}function markRawChildren(e){return"string"==typeof e?markHTMLString(e):Array.isArray(e)?e.map((e=>markRawChildren(e))):e}function transformSetDirectives(e){if("set:html"in e.props||"set:text"in e.props){if("set:html"in e.props){const t=markRawChildren(e.props["set:html"]);return delete e.props["set:html"],void Object.assign(e.props,{children:t})}if("set:text"in e.props){const t=e.props["set:text"];return delete e.props["set:text"],void Object.assign(e.props,{children:t})}}}function createVNode(e,t){const r={[Renderer]:"astro:jsx",[AstroJSX]:!0,type:e,props:t??{}};return transformSetDirectives(r),transformSlots(r),r}export{AstroError,AstroJSX,ExpectedImage,ExpectedImageOptions,Fragment,ImageMissingAlt,IncompatibleDescriptorOptions,InvalidImageService,LocalImageUsedWrongly,MissingImageDimension,MissingSharp,UnsupportedImageConversion,UnsupportedImageFormat,addAttribute,createAstro,createComponent,createVNode,maybeRenderHead,renderComponent,renderHead,renderJSX,renderSlot,renderTemplate,spreadAttributes,unescapeHTML};